

이 포스트에서는 JWT의 특징들에 대해서보다는 현실세계의 편지를 예로들어 큰 맥락을 이해하기 위한 내용을 다루고 있다.


## 용어정리

설명의 편의를 위해 용어정리를 하면

1. A4용지 한장에 담겨있는 문자열이다. = JWT편지
2. 편지를 읽고 읽을 사람 = 수신인
3. 편지를 읽기전용으로 만들어서 보내고 싶은 사람 = 발신인
4. 편지를 옮기는 사람 = 우체부

으로 설명한다.

----

## JWT편지

JWT편지는 특별한 디지털 편지이다. 해당 편지를 가진 사람은 누구나 읽을 수 있으나

`시크릿 키`없이는 편지의 내용을 수정할 수 없다.

## JWT편지의 발송과 수신까지

JWT편지는 아래 순서로 발송/수신 된다.

1. 발신인이 `시크릿 키`를 이용해 편지를 작성하고 우체부를 통해 편지를 보낸다.

2. 우체부는 몰래 그 편지를 읽을 수 있지만 시크릿 키가 없어서 수정은 불가하다.

3. 우체부를 통해 수신인은 편지를 받고 읽어 볼 수 있지만 역시 시크릿 키가 없어서 수정은 불가능하다.

4. 우체부의 관리 부실로 수신인이 아닌 제3자에게 편지가 가버릴 수 있으나 역시 수정은 불가능



## JWT편지의 내용은?

JWT편지는 읽기전용의 편지이므로 특별한 목적을 가지고 사용된다.

예를들어 이달의 가스






`특정 값`을 `시크릿 키`를 가지고 있는 사람만 수정가능하게 하고 `그 값`을 받는 상대는 읽기전용으로만 사용이 가능하다.



이런 방식의 장점은 

#### 값을 사용하는 사람의 입장

자기가 편한 방법으로 값을 사용할 수 있다.

#### 그 값을 발행한 사람의 입장

발행한 사람이 정의한 값을 멋대로 바꿀 수 없게 강제가 가능하다.



1. 값을 사용하는 사람이 값을 바꿔서 





현실세계로 예를들면 




### JWT로 검색하면 자주 나오는 특징들

1. JWT는 Json Web Token의 약자이다.(JOT이라고 발음한다.) 
2. Json 포맷을 이용하여 사용자에 대한 속성을 저장한다.
3. Claim 기반의 Web Token이다.
4. JWT는 토큰 자체를 정보로 사용하는 자가수용적(Self-Contained) 방식이다.
5. 정보를 안전하게 전달한다.
6. 웹표준 (RFC 7519)


이 특징들에 각각 알아보자.

## 1. JWT는 Json Web Token의 약자이다.(JOT이라고 발음한다.) 

제곧내


## 4.　JWT는 토큰 자체를 정보로 사용하는 자가수용적(Self-Contained) 방식이다.

자가 수용적 (self-contained)이 무슨말이냐면 필요한 모든 정보를 자체적으로 가지고 있다는 얘기이다.

정확히는 토큰에 대한 기본정보(header),전달 할 정보(payload),토큰이 검증을 증명해주는 값(signature)을 모두 jwt안에서 가지고 있는데

현실세계를 예로들면 한국의 어떤 자격증을 외국에서 증명할때 `자격증정보(header)` `자격증을 외국어로 번역한 내용(payload)` `외국어로 번역한 내용이 변조되지 않았는지 타기관의 공증` 뭐 이런것들을 하나의 a4용지안에 일괄적으로 구현했다고 생각하자.


## 6. 웹표준 (RFC 7519)

제곧내





## 사용용도

주로 회원 인증이나 정보 전달에 사용되는 JWT는 아래의 로직을 따라서 처리된다.

## header


 전자 서명 된 URL-safe (URL로 이용할 수있는 문자로만 구성된)의 JSON이다.

이는 속성정보(claim)를 JSon 데이터 구조로 표현한 토큰으로 RFC7519표준이다.

보통 JWT는 서버와 클라이언트 간 정보를 주고 받을 때 Http 리퀘스트 헤더에 JSON 토큰을 넣은 후 서버는 별도의 인증 과정 없이 헤더에 포함되어 있는 JWT 정보를 통해 인증한다.
이때 사용되는 JSON 데이터는 URL-safe 하도록 URL에 포함될 수 있는 문자만으로 만든다.
JWT 토큰 구성

header는 토큰의 타입과 해시 암호화 알고리즘으로 구성되어 있다. 첫째는 토큰의 유형, 둘째는 HMAC, SHA256과 같은 해시 알고리즘을 나타낸다.
payload는 토큰에 담을 클레임 정보(간단하게 말해서 토큰에 넣고 싶은 정보를 json 형태로)를 포함하고 있다. payload에 담는 정보의 한 조각을 클레임이라고 부르고, 이는 name/ value 한 쌍으로 이루어져 있다. 토큰에는 여러개의 클레임을 넣을 수 있으며 이는 등록된(registered), 공개(public), 비공개(private) 클레임으로 세 종류가 있다.
signature는 secret key를 포함하여 암호화되어 있다.


---
---

https://m.blog.naver.com/PostView.nhn?blogId=newyorkinms&logNo=220889126060&proxyReferer=https:%2F%2Fwww.google.com%2F





JWT는 세션/쿠키와 함께 모바일과 웹의 인증을 책임지는 대표주자입니다. JWT는 Json Web Token의 약자로(외국에서 ‘JOT’으로 읽는다네요 호호) 인증에 필요한 정보들을 암호화시킨 토큰을 뜻합니다. 위의 세션/쿠키 방식과 유사하게 사용자는 Access Token(JWT 토큰)을 HTTP 헤더에 실어 서버로 보내게 됩니다.

# JWT특징

세션/쿠키 방식과 유사하게 사용자는 Access Token(JWT 토큰)을 HTTP 헤더에 실어 서버로 보내게 됩니다.

## JWT의 토큰구성


---
토큰을 만들기 위해서는 크게 3가지, `Header`,`Payload`, `Verify Signature`가 필요합니다.

JWT는 Header, Payload, Signature의 3 부분으로 이루어지며, Json 형태인 각 부분은 Base64로 인코딩 되어 표현된다. 또한 각각의 부분을 이어 주기 위해 . 구분자를 사용하여 구분한다. 추가로 Base64는 암호화된 문자열이 아니고, 같은 문자열에 대해 항상 같은 인코딩 문자열을 반환한다.

### Header

위 3가지 정보를 암호화할 방식(alg), 타입(type) 등이 들어갑니다.

### Payload

서버에서 보낼 데이터가 들어갑니다. 일반적으로 유저의 고유 ID값, 유효기간이 들어갑니다.

### Verify Signature

Base64 방식으로 인코딩한 Header,payload 그리고 SECRET KEY를 더한 후 서명됩니다.





## JWT 장점
---

1. 간편합니다. 세션/쿠키는 별도의 저장소의 관리가 필요합니다. 그러나 JWT는 발급한 후 검증만 하면 되기 때문에 추가 저장소가 필요 없습니다. 이는 Stateless 한 서버를 만드는 입장에서는 큰 강점입니다. 여기서 Stateless는 어떠한 별도의 저장소도 사용하지 않는, 즉 상태를 저장하지 않는 것을 의미합니다. 이는 서버를 확장하거나 유지,보수하는데 유리합니다.
2. 확장성이 뛰어납니다. 토큰 기반으로 하는 다른 인증 시스템에 접근이 가능합니다. 예를 들어 Facebook 로그인, Google 로그인 등은 모두 토큰을 기반으로 인증을 합니다. 이에 선택적으로 이름이나 이메일 등을 받을 수 있는 권한도 받을 수 있습니다. 


## JWT 단점

Self-contained: 토큰 자체에 정보를 담고 있으므로 양날의 검이 될 수 있다.

토큰 길이: 토큰의 페이로드(Payload)에 3종류의 클레임을 저장하기 때문에, 정보가 많아질수록 토큰의 길이가 늘어나 네트워크에 부하를 줄 수 있다.

Payload 인코딩: 페이로드(Payload) 자체는 암호화 된 것이 아니라, BASE64로 인코딩 된 것이다. 중간에 Payload를 탈취하여 디코딩하면 데이터를 볼 수 있으므로, JWE로 암호화하거나 Payload에 중요 데이터를 넣지 않아야 한다.

Stateless: JWT는 상태를 저장하지 않기 때문에 한번 만들어지면 제어가 불가능하다. 즉, 토큰을 임의로 삭제하는 것이 불가능하므로 토큰 만료 시간을 꼭 넣어주어야 한다.

Tore Token: 토큰은 클라이언트 측에서 관리해야 하기 때문에, 토큰을 저장해야 한다.


여기까지의 글만 봤을 때는 JWT가 세션/쿠키 방식보다 더 효율적으로 보입니다. 하지만 JWT도 단점들이 존재합니다. 
(단점)
1. 이미 발급된 JWT에 대해서는 돌이킬 수 없습니다. 세션/쿠키의 경우 만일 쿠키가 악의적으로 이용된다면, 해당하는 세션을 지워버리면 됩니다. 하지만 JWT는 한 번 발급되면 유효기간이 완료될 때 까지는 계속 사용이 가능합니다. 따라서 악의적인 사용자는 유효기간이 지나기 전까지 신나게 정보들을 털어갈 수 있습니다. 
-> 해결책
기존의 Access Token의 유효기간을 짧게 하고 Refresh Token이라는 새로운 토큰을 발급합니다. 그렇게 되면 Access Token을 탈취당해도 상대적으로 피해를 줄일 수 있습니다. 이는 다음 포스팅에 나올 Oauth2에 더 자세히 다루도록 하겠습니다.

2. Payload 정보가 제한적입니다. 위에서 언급했다시피 Payload는 따로 암호화되지 않기 때문에 디코딩하면 누구나 정보를 확인할 수 있습니다. (세션/쿠키 방식에서는 유저의 정보가 전부 서버의 저장소에 안전하게 보관됩니다) 따라서 유저의 중요한 정보들은 Payload에 넣을 수 없습니다.

3. JWT의 길이입니다. 세션/쿠키 방식에 비해 JWT의 길이는 깁니다. 따라서 인증이 필요한 요청이 많아질 수록 서버의 자원낭비가 발생하게 됩니다.

Self-contained: 토큰 자체에 정보를 담고 있으므로 양날의 검이 될 수 있다.

토큰 길이: 토큰의 페이로드(Payload)에 3종류의 클레임을 저장하기 때문에, 정보가 많아질수록 토큰의 길이가 늘어나 네트워크에 부하를 줄 수 있다.

Payload 인코딩: 페이로드(Payload) 자체는 암호화 된 것이 아니라, BASE64로 인코딩 된 것이다. 중간에 Payload를 탈취하여 디코딩하면 데이터를 볼 수 있으므로, JWE로 암호화하거나 Payload에 중요 데이터를 넣지 않아야 한다.

Stateless: JWT는 상태를 저장하지 않기 때문에 한번 만들어지면 제어가 불가능하다. 즉, 토큰을 임의로 삭제하는 것이 불가능하므로 토큰 만료 시간을 꼭 넣어주어야 한다.

Tore Token: 토큰은 클라이언트 측에서 관리해야 하기 때문에, 토큰을 저장해야 한다.

---





JSON Web Token (JWT) 은 웹표준 (RFC 7519) 으로서 두 개체에서 JSON 객체를 사용하여 가볍고 자가수용적인 (self-contained) 방식으로 정보를 안전성 있게 전달해줍니다.

수많은 프로그래밍 언어에서 지원됩니다
JWT 는 C, Java, Python, C++, R, C#, PHP, JavaScript, Ruby, Go, Swift 등 대부분의 주류 프로그래밍 언어에서 지원됩니다.






> JWT 는 필요한 모든 정보를 자체적으로 지니고 있습니다. JWT 시스템에서 발급된 토큰은, 토큰에 대한 기본정보, 전달 할 정보 (로그인시스템에서는 유저 정보를 나타내겠죠?) 그리고 토큰이 검증됐다는것을 증명해주는 signature 를 포함하고있습니다.

## 쉽게 전달 될 수 있습니다

JWT 는 자가수용적이므로, 두 개체 사이에서 손쉽게 전달 될 수 있습니다. 웹서버의 경우 HTTP의 헤더에 넣어서 전달 할 수도 있고, URL 의 파라미터로 전달 할 수도 있습니다.

JWT 는 . 을 구분자로 3가지의 문자열로 되어있습니다. 구조는 다음과 같이 이루어져있습니다:


-----------------

   2.1 등록된 클레임(Registered Claim)
 

등록된 클레임은 토큰 정보를 표현하기 위해 이미 정해진 종류의 데이터들로, 모두 선택적으로 작성이 가능하며 사용할 것을 권장한다. 또한 JWT를 간결하게 하기 위해 key는 모두 길이 3의 String이다. 여기서 subject로는 unique한 값을 사용하는데, 사용자 이메일을 주로 사용한다.

 

iss: 토큰 발급자(issuer)

sub: 토큰 제목(subject)

aud: 토큰 대상자(audience)

exp: 토큰 만료 시간(expiration), NumericDate 형식으로 되어 있어야 함 ex) 1480849147370

nbf: 토큰 활성 날짜(not before), 이 날이 지나기 전의 토큰은 활성화되지 않음

iat: 토큰 발급 시간(issued at), 토큰 발급 이후의 경과 시간을 알 수 있음

jti: JWT 토큰 식별자(JWT ID), 중복 방지를 위해 사용하며, 일회용 토큰(Access Token) 등에 사용

 

    2.2 공개 클레임(Public Claim)
 

공개 클레임은 사용자 정의 클레임으로, 공개용 정보를 위해 사용된다. 충돌 방지를 위해 URI 포맷을 이용하며, 예시는 아래와 같다.

 

1
{ "https://mangkyu.tistory.com": true }
 
 
 

    2.3 비공개 클레임(Private Claim)
 

비공개 클레임은 사용자 정의 클레임으로, 서버와 클라이언트 사이에 임의로 지정한 정보를 저장한다. 아래의 예시와 같다.

 

1
{ "token_type": access }
 
 
 

 

1. Signature(서명)
서명(Signature)은 토큰을 인코딩하거나 유효성 검증을 할 때 사용하는 고유한 암호화 코드이다. 서명(Signature)은 위에서 만든 헤더(Header)와 페이로드(Payload)의 값을 각각 BASE64로 인코딩하고, 인코딩한 값을 비밀 키를 이용해 헤더(Header)에서 정의한 알고리즘으로 해싱을 하고, 이 값을 다시 BASE64로 인코딩하여 생성한다.

### reference:


[JWT 토큰(Token) 기반 인증에 대한 소개]: https://velopert.com/2350
[JSON Web Token 소개 및 구조]: https://velopert.com/2389
[JWT(Json Web Token)란?]: https://mangkyu.tistory.com/56
[쉽게 알아보는 서버 인증 2편(Access Token + Refresh Token)]: https://tansfil.tistory.com/59?category=255594

[생활코딩 jwt토론]: https://www.facebook.com/groups/codingeverybody/permalink/5123245734382588/


```

https://tansfil.tistory.com/58

```