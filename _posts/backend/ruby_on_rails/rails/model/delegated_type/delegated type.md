これはDjangoの「multi-table inheritance」と呼ばれるものに似ているが、実際にはこのアプローチで使うのは継承ではなく、階層を形成して責務を共有するのに「委譲（delegation）」を用いる。

新規レコードの作成
「delegated typing」を用いてレコードを1件作成するには、次のようにdelegatorとdelegeteeを同時に作成する。

Entry.create! message: Comment.new(content: "Hello!"), creator: Current.user

「STI（Single-Table Inheritance）のつらみを避けるためにDHHが実装したということみたい」「普通のモジュールインクルードとどう違うのかな？👀」

STIだと説明にもあるように全サブクラスの属性が1個のテーブルに入ってしまってテーブルがでかくなると」「DHHも『どちらにも使い所はあるけどそれぞれ欠点がある』って書いてる😆」

それがdelegated typingだとそれぞれが独自テーブルを持つからSTIの形にはならなくなるのか」「DHHは『第3の方法』と呼んでますね」「第3😆」「Djangoのmulti-table inheritanceにも似てるみたい」

うん、サンプルコード↓を見るとEntryもMessageもCommentも単にApplicationRecordを継承してる: なるほどだんだん見えてきた😋」「delegate typingでは、共通のカラムはEntryにあるけど差分のテーブルはMessageやCommentにあって、それらがデータベース上Entryへの参照を持っていると」「EntryはEntryableモジュールを取ってくることでワンクッション置いてるのね☺️」

もちろんSTIでも問題なくやれる場合はあります: STIで一番問題になりやすいのは、まさにこのサンプルコードでやっているみたいに、リッチテキストのようなむちゃくちゃ大きいコンテンツが入ってくるカラムをSTIで増やすと行サイズがバカでかくなること😇」「そうですね😅」「ほとんどのカラムが共通カラムで、ごく一部のカラムだけが特定のテーブル用に追加される形（integerカラムをちょっと足す程度）なら、STIでも大したことにはなりませんし🧐」「ふむふむ」「STIで特定のテーブルにしかないカラムが長大になると（text型とか）、データベース上の無駄が多すぎるんですよ😢」
「そういう長大なカラムを使う場合は明らかにこのdelegated typingの方がいいでしょうね❤️: データモデル的にもキレイですし、オブジェクト指向プログラミングでよく言われる『なるべく委譲しよう』的な考え方ですし🧐」「おぉ😍」「サブクラスを増やして継承するより先にデリゲートを検討しましょう、コンポジションしましょうというヤツ☺️」「なるほど！」
参考: Rubyによるデザインパターン5原則 - Qiita

「もちろんどんな場合でもdelegated typingがいいわけではないと思います: STIの方が速くなることも普通にありますので🚀」「設計の選択肢が増えるのはいいこと👍」

https://techracho.bpsinc.jp/hachi8833/2020_06_01/92842
https://github.com/rails/rails/pull/39341/files
